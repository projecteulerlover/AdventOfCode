ROUTINE AoC2020Day20

Start() PUBLIC {
	s input="/irisdev/app/inputs/input20.txt"
	d readInput(input, .in)
	
	d getEdgeMapping(.in, .edgeToHas, .tileToEdges, .hashToEdge)

	s edges=1
	s unique=2
	while edges'="" {
		s edges=""
		s v= $$p1(.in, .edges, unique)
		
		for i=2:1:$length(edges, ",") {
			s c=$p(edges, ",", i)
			kill in(c)
		}
		s unique=unique+1
	}
	return 1
}

lrflip(tile) PUBLIC {
	for i=1:1:10 {
		s tile(i)=$reverse(tile(i))
	}
}

rotate90(tile) PUBLIC {
	for i=1:1:5 {
		for j=i:1:10-i {
			s tmp=$e(tile(i), j)
			s $e(tile(i), j) = $e(tile(10-j+1), i)
			s $e(tile(10-j+1), i) = $e(tile(10-i+1), 10-j+1)
			s $e(tile(10-i+1), 10-j+1) = $e(tile(j), 10-i+1)
			s $e(tile(j), 10-i+1) = tmp
		}
	}
}

getEdgeMapping(in, edgeToHash, tileToEdges, hashToEdge) PUBLIC {
	s id=""
	s hash=1
	for {
		s id=$o(in(id))
		if id="" quit

		s t=in(id, 1)
		s b=in(id, 10)
		s l="", r=""
		for i=1:1:10 {
			s $e(l, i)=$e(in(id, i), 1)
			s $e(r, i)=$e(in(id, i), 10)
		}

		s sides=$lb(t, b, l, r)
		for i=1:1:$LISTLENGTH(sides) {
			s curr=$list(sides, i)

			if $d(edgeToHash(curr)) || $d(edgeTohas($reverse(curr))) continue

			s edgeToHash(curr)=hash
			s edgeToHash($reverse(curr))=hash
			s hashToEdge(hash)=curr_","_$reverse(curr)

			s hash=hash+1
		}
	}
}

p1(in, edges, unique) PUBLIC {
	s id=""
	for {
		s id=$o(in(id))
		if id="" quit

		
		if $d(count(in(id, 1))) {
			s str = in(id, 1)
		} else {
			s str = $reverse(in(id, 1))
		}
		s count(str)=$g(count(str))+1
		s count(str, id)=""

		if $d(count(in(id, 10))) {
			s str = in(id, 10)
		} else {
			s str = $reverse(in(id, 10))
		}
		s count(str)=$g(count(str))+1
		s count(str, id)=""

		s l=""
		s r=""

		for i=1:1:10 {
			s $e(l, i)=$e(in(id, i), 1)
			s $e(r, i)=$e(in(id, i), 10)
		}

		if $d(count(l)) {
			s str = l
		} else {
			s str = $reverse(l)
		}
		s count(str)=$g(count(str))+1
		s count(str, id)=""

		if $d(count(r)) {
			s str = r
		} else {
			s str = $reverse(r)
		}
		s count(str)=$g(count(str))+1
		s count(str, id)=""
	}
	

	s pattern=""
	for {
		s pattern=$o(count(pattern),1,c)
		if pattern="" quit

		if c'=1 {
			k count(pattern)
		}
	}
	s p=""
	for {
		s p=$o(count(p))
		if p="" quit
		
		s fcount($o(count(p, "")))=$g(fcount($o(count(p, ""))))+1
	}
	s id=""
	s prod=1
	for{
		s id=$o(fcount(id),1,v)
		if id="" quit

		if v=unique {
			s edges=edges_","_id
			s prod=prod*id
		}
	}
	return prod
}


readInput(input, result) PUBLIC {
	set file = ##class(%Stream.FileCharacter).%New()
	s sc = file.LinkToFile(input)
	while 'file.AtEnd {
		s curr = $translate(file.ReadLine(), $c(13))

		if curr="" continue

		if $find(curr, "Tile") s j=$extract(curr, 6, *-1)
		for k=1:1:10 {
			s curr = $translate(file.ReadLine(), $c(13))
			s result(j, k)=curr
		}
	}
}